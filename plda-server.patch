diff -urbB plda/cmd_flags.cc plda-server/cmd_flags.cc
--- plda/cmd_flags.cc	2011-07-21 18:20:50.000000000 +0900
+++ plda-server/cmd_flags.cc	2014-10-15 21:25:59.289528475 +0900
@@ -32,6 +32,9 @@
   burn_in_iterations_ = -1;
   total_iterations_ = -1;
   compute_likelihood_ = "false";
+  src_sock_port_ = 0;
+  verbose_ = false;
+  daemonize_ = false;
 }
 
 void LDACmdLineFlags::ParseCmdFlags(int argc, char** argv) {
@@ -66,8 +69,16 @@
     } else if (0 == strcmp(argv[i], "--compute_likelihood")) {
       compute_likelihood_ = argv[i+1];
       ++i;
+    } else if (0 == strcmp(argv[i], "--src_sock_port")) {
+      std::istringstream(argv[i+1]) >> src_sock_port_;
+      ++i;
+    } else if (0 == strcmp(argv[i], "-v")) {
+      verbose_ = true;
+    } else if (0 == strcmp(argv[i], "--verbose")) {
+      verbose_ = true;
+    } else if (0 == strcmp(argv[i], "--daemonize")) {
+      daemonize_ = true;
     }
-
   }
 }
 
@@ -146,6 +157,7 @@
     std::cerr << "beta must > 0.\n";
     ret = false;
   }
+/*
   if (inference_data_file_.empty()) {
     std::cerr << "Invalid inference_data_file.\n";
     ret = false;
@@ -154,6 +166,7 @@
     std::cerr << "Invalid inference_result_file.\n";
     ret = false;
   }
+*/
   if (model_file_.empty()) {
     std::cerr << "Invalid model_file.\n";
     ret = false;
@@ -166,6 +179,10 @@
     std::cerr << "total_iterations must > burn_in_iterations.\n";
     ret = false;
   }
+  if (src_sock_port_ <= 0) {
+    std::cerr << "src_sock_port must > 0.\n";
+    ret = false;
+  }
   return ret;
 }
 
diff -urbB plda/cmd_flags.h plda-server/cmd_flags.h
--- plda/cmd_flags.h	2011-07-21 18:20:50.000000000 +0900
+++ plda-server/cmd_flags.h	2014-10-15 21:26:58.190855640 +0900
@@ -38,6 +38,9 @@
   int         burn_in_iterations_;
   int         total_iterations_;
   std::string compute_likelihood_;
+  int         src_sock_port_;
+  bool        verbose_;
+  bool        daemonize_;
 };
 
 }  // namespace learning_lda
diff -urbB plda/infer.cc plda-server/infer.cc
--- plda/infer.cc	2011-07-21 18:20:50.000000000 +0900
+++ plda-server/infer.cc	2014-10-15 22:35:15.160394364 +0900
@@ -34,33 +34,170 @@
 #include "sampler.h"
 #include "cmd_flags.h"
 
-int main(int argc, char** argv) {
-  using learning_lda::LDACorpus;
-  using learning_lda::LDAModel;
-  using learning_lda::LDAAccumulativeModel;
-  using learning_lda::LDASampler;
-  using learning_lda::LDADocument;
-  using learning_lda::LDACmdLineFlags;
-  using learning_lda::DocumentWordTopicsPB;
-  using learning_lda::RandInt;
-  using std::ifstream;
-  using std::ofstream;
-  using std::istringstream;
+#include <iostream>
+#include <pthread.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h> // inet_ntoa
+#include <sys/wait.h> // waitpid
+#include <string.h> // bzero()
+#include <sys/syscall.h> // syscall()
+#include <sys/time.h> // usleep()
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <unistd.h> //setsid etc.
 
-  LDACmdLineFlags flags;
-  flags.ParseCmdFlags(argc, argv);
-  if (!flags.CheckInferringValidity()) {
-    return -1;
-  }
-  srand(time(NULL));
-  map<string, int> word_index_map;
-  ifstream model_fin(flags.model_file_.c_str());
-  LDAModel model(model_fin, &word_index_map);
-  LDASampler sampler(flags.alpha_, flags.beta_, &model, NULL);
-  ifstream fin(flags.inference_data_file_.c_str());
-  ofstream out(flags.inference_result_file_.c_str());
+#define LBUF  65535
+
+using learning_lda::LDACorpus;
+using learning_lda::LDAModel;
+using learning_lda::LDAAccumulativeModel;
+using learning_lda::LDASampler;
+using learning_lda::LDADocument;
+using learning_lda::LDACmdLineFlags;
+using learning_lda::DocumentWordTopicsPB;
+using learning_lda::RandInt;
+using std::ifstream;
+using std::ofstream;
+using std::istringstream;
+
+using namespace std;
+
+// signal
+int g_srcSocket;
+
+/*
+void Wait(int sig){
+  while(waitpid(-1,NULL,WNOHANG)<0);
+  signal(SIGCHLD, Wait);
+}
+*/
+
+void Finish(int sig){
+    cout << "SIGTERM: Close the socket(" << g_srcSocket << ")" << endl;
+    close(g_srcSocket);
+}
+
+pid_t gettid(void)
+{
+    return syscall(SYS_gettid);
+}
+
+struct inf_data {
+    int sock;
+	string client_ip;
+    string res;
+    LDACmdLineFlags *flags;
+    map<string, int> *word_index_map;
+    LDAModel *model;
+    LDASampler *sampler;
+};
+
+/*
+int get_pid_sh()
+{
+    FILE *pipe;
+    pipe = popen("ps aux | grep xxx | grep -v grep | awk '{print $2}'","r");
+    char buf[100];
+    fread(buf,sizeof(char),100,pipe);
+    return atoi(buf);
+}
+*/
+
+void* infer(void* p){
+
+    struct inf_data* infdata = (struct inf_data*)p;
+    int dstSocket  = infdata->sock;
+	string client_ip = infdata->client_ip;
+
+    map<string, int> *word_index_map = infdata->word_index_map;
+    LDAModel *model = infdata->model;
+    LDACmdLineFlags *flags = infdata->flags;
+
+    int width;
+    fd_set mask;
+
+    FD_ZERO(&mask);
+    FD_SET(dstSocket, &mask);
+    width = dstSocket+1;
+ 
+    pid_t tid=gettid();
+    if(flags->verbose_)
+		cout << "Thread id : " << tid << endl;
+
+
+    int n=0,numrcv=0;
+    char buf[LBUF] = {'\0'};
   string line;
-  while (getline(fin, line)) {  // Each line is a training document.
+    fd_set readok;
+
+    for(;;){
+
+        line.clear();
+
+        for(;;){
+ 
+            memcpy(&readok,&mask,sizeof(fd_set));
+
+        	//n = select(width, &readok, NULL, NULL, &tv);
+	        n = select(width, &readok, NULL, NULL, NULL);
+
+	        if( n==-1 ) {
+				cerr << "@select: Error " << errno << " in a thread(" << tid << ")." << endl;
+         	    shutdown(dstSocket,SHUT_RDWR);
+
+                break;
+
+            }else if( n==0 ){
+				cerr << "@select: Timeout " << errno << " in a thread(" << tid << ")." << endl;
+                shutdown(dstSocket,SHUT_RDWR);
+
+	   	        // For my own experiment //
+  		        /*
+                int pid_sh = get_pid_sh();
+                char command[100]={};
+                sprintf(command,"kill -USR1 %d",pid_sh);
+                system(command);
+		        */
+
+                break;
+
+            }
+  
+            if(!FD_ISSET(dstSocket,&readok))
+                continue;
+  
+            memset(buf,'\0',LBUF);
+            numrcv = read(dstSocket, buf, LBUF);
+            if( numrcv==-1 ){ // socket shutdowned
+                cout << "@read: Socket shutdowned(" << dstSocket << ")." << endl;
+                close(dstSocket);
+
+                break;
+
+            }else if( numrcv==0 ){ // socket closed
+                cout << "@read: Socket was closed(" << dstSocket << ")." << endl;
+                close(dstSocket);
+
+                break;
+
+			}
+
+            line += (string)buf;
+			// The end of data is '\n'
+            if(line.size()>1 && line.at(line.size()-1)=='\n'){
+                break;
+            }
+
+        } // select & read loop ends
+
+        if( n==0 || n==-1 ) break; // select error/timeout
+        if( numrcv==0 || numrcv==-1 ) break; // socket closed/shutdowned
+  
+
+        LDASampler sampler(flags->alpha_, flags->beta_, model, NULL);
+  
     if (line.size() > 0 &&      // Skip empty lines.
         line[0] != '\r' &&      // Skip empty lines.
         line[0] != '\n' &&      // Skip empty lines.
@@ -68,22 +206,33 @@
       istringstream ss(line);
       DocumentWordTopicsPB document_topics;
       string word;
-      int count;
+            int count,term_count=0;
+
       while (ss >> word >> count) {  // Load and init a document.
         vector<int32> topics;
         for (int i = 0; i < count; ++i) {
-          topics.push_back(RandInt(model.num_topics()));
+                    topics.push_back(RandInt(model->num_topics()));
         }
-        map<string, int>::const_iterator iter = word_index_map.find(word);
-        if (iter != word_index_map.end()) {
+
+                map<string, int>::const_iterator iter = word_index_map->find(word);
+                if (iter != word_index_map->end()) {
           document_topics.add_wordtopics(word, iter->second, topics);
         }
+				term_count++;
+            }
+
+    		if(flags->verbose_){
+				cout << "Received from client[" << client_ip << "] (# of terms is ";
+				cout << term_count << "): " << line << endl;
       }
-      LDADocument document(document_topics, model.num_topics());
-      TopicProbDistribution prob_dist(model.num_topics(), 0);
-      for (int iter = 0; iter < flags.total_iterations_; ++iter) {
+
+
+            LDADocument document(document_topics, model->num_topics());
+            TopicProbDistribution prob_dist(model->num_topics(), 0);
+
+            for (int iter = 0; iter < flags->total_iterations_; ++iter) {
         sampler.SampleNewTopicsForDocument(&document, false);
-        if (iter >= flags.burn_in_iterations_) {
+                if (iter >= flags->burn_in_iterations_) {
           const vector<int64>& document_distribution =
               document.topic_distribution();
           for (int i = 0; i < document_distribution.size(); ++i) {
@@ -91,11 +240,115 @@
           }
         }
       }
+
+            double d;
+            string out="";
       for (int topic = 0; topic < prob_dist.size(); ++topic) {
-        out << prob_dist[topic] /
-              (flags.total_iterations_ - flags.burn_in_iterations_)
-            << ((topic < prob_dist.size() - 1) ? " " : "\n");
+                char tmp[16] = {'\0'};
+
+				//Original code
+                //out << prob_dist[topic] /
+                //      (flags.total_iterations_ - flags.burn_in_iterations_)
+                //    << ((topic < prob_dist.size() - 1) ? " " : "\n");
+  
+                d = prob_dist[topic] /\
+                    (flags->total_iterations_ - flags->burn_in_iterations_);
+
+                sprintf(tmp,"%.2f",d);
+                out += (string)tmp;
+                out += ((topic < prob_dist.size() - 1) ? " " : "\n");
+            }
+      
+            write(dstSocket, out.c_str(), out.size());
+
+        } // if
+
+    } // for(;;)
+
+    return 0;
+}
+
+int main(int argc, char** argv) {
+
+  LDACmdLineFlags flags;
+  flags.ParseCmdFlags(argc, argv);
+  if (!flags.CheckInferringValidity()) {
+    return -1;
+  }
+  srand(time(NULL));
+
+  map<string, int> word_index_map;
+  ifstream model_fin(flags.model_file_.c_str());
+  LDAModel model(model_fin, &word_index_map);
+
+  struct sockaddr_in srcAddr;
+  bzero((char*)&srcAddr, sizeof(srcAddr));
+
+  srcAddr.sin_port = htons(flags.src_sock_port_);
+  srcAddr.sin_family = AF_INET;
+  srcAddr.sin_addr.s_addr = INADDR_ANY;
+
+  int srcSocket = socket(AF_INET, SOCK_STREAM, 0);
+  g_srcSocket = srcSocket;
+
+  signal(SIGTERM, Finish);
+
+
+  int temp = 1;
+
+  // Next time, TIME_WAIT may cause the failure of bind
+  // SO_REUSEADDR option can avoid this issue
+  if(setsockopt(srcSocket, SOL_SOCKET, SO_REUSEADDR, &temp, sizeof(temp)))
+      fprintf(stderr, "setsockopt() failed");
+
+  if(bind(srcSocket, (struct sockaddr *)&srcAddr, sizeof(srcAddr))!=0){
+      printf("bind failed %d\n",errno);
+      return -1;
+  }
+
+  if(listen(srcSocket, 100)!=0){
+      printf("listen failed %d\n",errno);
+      return -1;
       }
+
+  if(flags.daemonize_){
+      pid_t pid;
+
+      // parent should exit to make child daemonize
+      if((pid=fork())>0) exit(1);
+
+      // Create new session without terminal control
+      pid=setsid();
+  }
+
+  int dstSocket;
+  struct sockaddr_in dstAddr;
+  int dstAddrSize = sizeof(dstAddr);
+
+  for(;;){
+
+    dstSocket = accept(srcSocket, (struct sockaddr *)&dstAddr, (socklen_t *)&dstAddrSize);
+    if( dstSocket <= 0 ){
+        cerr << "@accept: Socket was closed(" << srcSocket << ")." << endl;
+        break;
     }
+
+    {
+        struct inf_data infdata;
+
+        infdata.sock = dstSocket;
+		infdata.client_ip = inet_ntoa(dstAddr.sin_addr);
+        infdata.word_index_map = &word_index_map;
+        infdata.model = &model;
+        infdata.flags = &flags;
+
+        pthread_t pt;
+        pthread_create(&pt,NULL,infer,(void *)&infdata);
+        pthread_detach(pt);
   }
+
+  }
+
+  return 0;
 }
+
diff -urbB plda/Makefile plda-server/Makefile
--- plda/Makefile	2011-07-21 18:20:50.000000000 +0900
+++ plda-server/Makefile	2014-10-13 17:06:51.408323625 +0900
@@ -1,7 +1,7 @@
 CC=g++
 MPICC=mpicxx
 
-CFLAGS=-O3 -Wall -Wno-sign-compare
+CFLAGS=-O3 -Wall -Wno-sign-compare -lpthread
 
 all: lda infer mpi_lda
 
